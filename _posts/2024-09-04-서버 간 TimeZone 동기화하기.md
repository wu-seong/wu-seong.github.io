---
title: 서버 간 TimeZone 동기화하기
date: 2024-09-04 00:00:00 +/- TTTT
categories: [project, 탐식당]
tags: [트러블 슈팅]	# TAG는 반드시 소문자로 이루어져야함!
---
<style>
  figcaption {
    font-size: 14px;
    color: #555;
    font-style: italic;
  }
</style>

## 문제 상황

알림 시간이 UTC로 저장되어 알림 센터에 시간이 9시간 이르게 표시됨

## 원인 분석
알림 보낼 시에 서버에서 now로 현재 시간을 저장하는데 JVM의 시간대가 기본 시간대인 UTC라서 이를 한국 시간보다 9시간 이르게 저장됨

## 문제 해결
-> JVM 시간대를 바꿈

## 새로운 문제상황 발생
식단 등록시에 등록한 LocalDate 타입의 정보가 1일 더 빠르게 저장됨

### 1차 의문
LocalDate는 TimeZone 정보를 저장하지 않는데 왜 바뀌는 것인지 의문

가정: DB의 Global 시간대를 기준으로 싱크를 맞춘다. 이 과정에서 LocalDate을 자정 시간으로 변경 후 싱크를 맞추어 원래 일자보다 더 빨라지는 것임

Global 시간대에 대해서 조금 말하자면 
DB는 Connection마다 시간대 정보를 독립적으로 유지함
디폴트 시간대는 Global TimeZone이 따로 있음

나는 원래 연결마다 TimeZone을 KST로 맞춰놨음
그럼 KST - KST로 싱크가 맞아야 하는데 안맞아서 위와 같은 가정을 해봄

그래서 DB의 Global 시간대도 UTC+9로 맞춰 놓음
### 2차 의문
바꿔놓았음에도 불구하고 변하지 않음 

[stackoverflow 답변](https://stackoverflow.com/questions/54418827/mysql-date-changes-to-yesterdays-date-after-jpa-save)
찾아보니 hikariCP에서 TimeZone 정보를 캐싱을 한다고 함 
이 캐싱은 우선적으로 TimeZone을 결정하여 이 캐시 정보 때문에 제대로 적용이 않은 것이었음

따라서 서버 상에서는 KST 시간대를 사용했지만 막상 DB와의 세션에서는 여전히 UCT를 사용하는 것으로 간주하여 KST 시간이 UTC 시간으로 바뀌어 DB에 9시간이 더 이르게 저장 되는 것임
2024-09-03T00:00:00(UTC+9) -> 2024-09-02T15:00:00(UTC+0)

따라서 이전의 가정은 틀렸으며 시간대도 JVM 시간대를 따른다고 한다.


## 결론

1. 기본적으로 Java의 LocalDate 타입과 Mysql에서 Date 타입은 TimeZone 정보를 포함하지 않는다.
2. 만약 JVM 시간대와 캐시된 시간대가 다르다면 JVM에서 저장한 시간대가 UTC 시간대로 잘못 해석될 수 있다.(이 때 LocalDate역시 TimeZone의 영향을 받는다.)
-> JVM 시간대와 DB 서버 시간대를 맞추고, HikariCP에서 이전 세션 시간대를 캐싱하는 것에 주의하자(최신화된 JVM 시간대 이전 시간대 정보로 잘못 해석할 수 있음)


## 참고자료

[mysql 공식문서 - ](https://dev.mysql.com/doc/refman/8.4/en/datetime.html)