---
title: 스프링 핵심원리 - 기본편 정리1
date: 2023-01-18 00:00:00 +/- TTTT
categories: [Spring, 스프링 핵심원리]
tags: [강의정리]		# TAG는 반드시 소문자로 이루어져야함!
---

## 스프링의 역사

EJB가 기업용 개발 소프트웨어를 장악 

-> 개발자들이 EJB를 사용하면서 불편함을 느낌(어렵고, 느리고, 복잡함)

-> POJO(plan of java object) 순수 자바로 돌아가자는 등 비판 여론 형성

-> *Rod Johnson(로드 존슨)*이 '*expert one-on-one J2EE Design and Development*' 라는 책을 내며 EJB를 사용하지 않고도 충분히 더 좋은 개발을 할 수 있다고 주장(실제로 코드를 책에서 구현하며)

-> 이를 본 *Juergen Hoeller(유겐 휠러)* 와 *Yann Caroff(얀 카로프)*가 존슨에게 Spring 프로젝트를 제안 

-> spring이 거의 J2EE(현재Jakarta EE)의 표준이 되며 현재까지도 개발 진행 중

*EJB란?*
`> Enterprise JavaBeans(EJB)는 기업환경의 시스템을 구현하기 위한 서버측 컴포넌트 모델이다.`
[EJB 위키백과](https://ko.wikipedia.org/wiki/%EC%97%94%ED%84%B0%ED%94%84%EB%9D%BC%EC%9D%B4%EC%A6%88_%EC%9E%90%EB%B0%94%EB%B9%88%EC%A6%88)

------------
## 스프링의 핵심 
스프링의 핵심 가치는 **좋은 객체 지향 프로그래밍**을 할수 있도록 도와주는 데에 있다.

*그렇다면 좋은 객체 지향 프로그래밍이란 뭘까?*

먼저 영한님은 객체지향을 바라보는 관점을 실세계에 비유하며 **역할**과 **구현** 두 가지 컨셉으로 나누는 방법을 소개해주었다. 그리고 이를 프로그래밍에서는 **다형성**을 통해서 적용할 수 있다고 보았다, 역할은 인터페이스, 구현은 인터페이스를 구현한 클래스, 구현 객체라고 본 것이다.

여튼 위와 같은 컨셉을 바탕으로 설계하고, 아래 5가지 원칙을 준수하면서 개발한다면 좋은 객체 지향 프로그밍을 한다고 볼 수 있을 것 같다.

* **SRP**(Single Responsibility) - 하나의 클래스(인터페이스)는  **한가지 책임**만을 져야한다 

* **OCP**(Open / Close) - **확장**에 대해서는 **열려**있고, **변경**에 대해서는 **닫혀**있어야한다.

* **LSP**(Liscov Substitution) - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다, 여기서 말하는 동작은 단순한 컴파일 동작이 아닌 실제로 명세에 맞게 동작하는 것을 의미한다.

* **ISP**(Interface Segrigation) - 클라이언트는 사용하지 않는 인터페이스에 강제로 의존해서는 안된다, 만약 그렇게 될 경우 인터페이스를 나누어야 한다.

* **DIP**(Dependency Inversion) - 제어의 역전,
1. 상위 모듈은 하위 모듈에 의존해서는 안 되고 둘 다 **추상화에 의존**해야 한다.
2. 추상화는 세부 사항에 의존해서는 안 되고 세부사항(구체적인 구현)은 **추상화에 의존**해야 한다. 


그런데, 만약 여기서 다형성을 이용하여 아래와 같은 구조로 설계한다고 했을 때

![다형성 활용 설계 예시](https://velog.velcdn.com/images/jws1228/post/5199d9db-eb40-47e7-8a67-6243e7829062/image.png)

먄약 기존 저장소 구현으로 메모리 저장소를 채택하고 있다가

![멤버 서비스 주입1](https://velog.velcdn.com/images/jws1228/post/be84d245-1a5e-4341-baaa-fbf0dbeb10bb/image.png)

JDBC저장소를 사용하는 것으로 구현을 바꿔야 한다면 다형성을 활용하여 아래와 같이 바꿀 수 있을 것이다.
![멤버 서비스 주입2](https://velog.velcdn.com/images/jws1228/post/1bbfcd77-fdfc-49c3-9eed-4ce868826f91/image.png)

하지만, 여기서 직접 서비스 로직의 코드를 변경해주어야 하기 때문에 OCP, DIP를 위반하게 된다. 그래서 추가적인 무언가가 필요하다.

### IOC(Inversion of Control)와 DI(Dependency Injection)
그것이 바로 **IOC**와 **DI** 이다.

먼저 **IOC**란, 객체의 제어권을 객체 스스로가 아닌 외부에서 가지고 제어 하는 것이다.

그리고 **DI**는 의존관계 주입으로, 앞에서 말한 제어권을 가지고 있는 외부에서 의존관계를 주입하여 실제 구현 객체를 제어하는 것이다.

위 개념을 통해 비즈니스 로직에 집중하는 코드와, 실제 어떤 객체를 사용할지를 제어하는 코드로, **관심사를 둘로 나누어** 각자 역할에 집중할 수 있다. 

이렇게 하면 앞에서 구현객체를 결정할 때 비즈니스 로직 코드는 그대로 두고 런타임에 외부에서 제어 객체를 직접 주입하여 **OCP와 DIP를 지킬 수 있다.** 
![외부의 AppConfig 객체가 제어권을 가지고 의존관계를 주입](https://velog.velcdn.com/images/jws1228/post/f4a9a81c-5a94-49e0-898b-31b766702416/image.png)

Service는 MemberRepository 인터페이스에 의존하고(추상화에 의존) 외부에서 AppConfig가 구체적인 의존관계를 주입하는 모습이다.

이 과정을 자바 코드로 직접 구현할 수도 있지만, **스프링 컨테이너**를 이용하면 이를 훨씬 더 간단히, 생산성있게 할 수 있다.


다음에는 예제를 통해서 스프링 컨테이너를 알아갔던 부분을 정리해볼 것이다.




좋은 강의를 해주신 영한님께 다시 한번 감사합니다!

--------------
자료 출처:[영한님 인프런 강의](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8)

