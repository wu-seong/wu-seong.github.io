---
title: 알고리즘 문제 풀이 - DP(3)
date: 2024-08-22 00:00:00 +/- TTTT
categories: [알고리즘, DP]
tags: [공부 정리,PS]	# TAG는 반드시 소문자로 이루어져야함!
---
<style>
  figcaption {
    font-size: 14px;
    color: #555;
    font-style: italic;
  }
</style>

## 서론
안녕하세요! 최근에도 코딩테스트 대비를 위해서 지속적으로 문제들을 풀고 있는데요, 요즘은 기출문제를 풀기 위해서 프로그래머스에서 카카오 기출문제들을 풀고 있습니다.

그런데 아직 제대로 복기하지 못한 백준 문제들이 많아서 이번 글에서 리뷰해보며 복기해보려고 합니다.

이번에 리뷰할 문제들은 **2차원**으로 부분 문제의 해를 저장해야하는 형식입니다.   
따라서 어떤 것을 기준으로 부분 문제로 나눌지를 생각하는 것이 중요하니, 이에 집중하면서 리뷰를 봐주시면 좋을 것 같습니다.

## 문제 리뷰

### 평범한 배낭
[평범한 배낭](https://www.acmicpc.net/problem/12865)
아주 대표적인 2차원 DP 문제입니다.

#### 문제 접근
Bottom-Up 방식으로 접근하여 **물건**이 1개 있을 때를 생각해보겠습니다.
만약 물건이 배낭의 무게를 넘지 않는다면 물건의 가치가 해가 되고, 만약 넘는다면 0이 해일 것입니다. 

다음은 물건이 2개 있을 때를 생각해보겠습니다.   
만약 이전에 물건을 1개 넣은것에 추가적으로 넣을 수 있다면 넣는 것이 당연히 더 높은 가치를 가질 것 입니다(음수의 가치는 없으므로)

그런데, 만약 무게가 부족해 둘 다 넣을 수가 없다면?   
둘 중에 1개를 선택해야하는 상황이 올 것 입니다.    
물건을 비교해서 가치가 높은 물건을 넣어야 합니다.

만약 물건이 3개가 있다면?   
모든 물건을 비교해서 가치가 높은 순부터 넣으면 될까요?   
아니면 물건을 많이 담기 위해서 무게가 낮은 순부터 넣으면 될까요? 

만약 무게나 가치가 일정하다면 정렬한 뒤 위처럼 그리디한 방법으로 선택하면 되겠지만   
물건의 무게와 가치는 랜덤하기 때문에 다른 방법을 생각해 봐야겠습니다.

DP 문제를 풀 때는 항상 **'이전에 구해놓은 부분 문제의 해'**를 이용하는 것이 중요합니다.   
만약 새로운 물건이 추가됐을 때 이 물건을 선택할지 말지를 판단할 때 이를 잘 이용해봅시다.🤔

가정을 한번 해보겠습니다.   
만약 새로운 물건의 가치가 100조 정도 되는 매우 큰 숫자라고 생각해보겠습니다.
배낭에 넣을 수 있는 물건이라면 다른 물건보다도 이 물건을 우선하여 반드시 넣어야 할 것입니다.   

그렇다면 이 새로운 물건을 넣고 나서 나머지 **무게**는 어떤 물건으로 채우는게 좋을까요?
방법은 잘 모르겠습니다만, 가장 가치가 높도록 채워야겠죠?   
여기가 바로 이 문제를 부분 문제로 나눌 수 있는 포인트 입니다!

위의 예시에선 물건의 가치가 매우 높아 새로운 **물건**을 선택했지만 항상 선택하는 것이 옳은 선택은 아니겠죠?   
만약 같은 무게더라도 전에 구했던 무게 당 가장 높은 가치가 더 높다면 새로운 물건을 선택할 이유가 없습니다.

그러면 **무게**와 **물건**을 기준으로 부분 문제를 해결하며 2차원 배열에 각 해를 저장해가면 될 것 같습니다.
어느정도 윤곽이 잡힌 것 같으니 점화식을 생각해 보겠습니다.🤗  

현재 물건을 넣고 남은 무게에 대한 최대 가치를 구해야 하니   
현재 물건의 무게만큼 뺀 것이 부분 문제가 될 것입니다.

> dp[n][m] = max(dp[n-1][m], 새로운 물건의 가치 + dp[n-1][m-새로운 물건의 무게]) // n:물건 , m:무게

이 점화식은 새로운 물건의 무게가 m보다 작을때만 적용하고 (물건을 넣을 수 있을 때)
만약 무게가 m 보다 클 때는 추가되도 넣을 수가 없으니 물건을 추가하기 이전과 같은 해를 가진다고 봐도 됩니다.

#### 주의할 점
물건의 개수는 1개이기 때문에 **물건을 중복해서 넣을 수 없음**에 주의해야 합니다.
따라서 남은 물건의 최대 가치를 반드시 '현재 물건이 추가되기 직전'에서 가져와야 합니다.   

따라서 **dp[n]이 아닌 dp[n-1]에서 남은 무게의 최대 가치를 가져오는 것**입니다.
만약 dp[n]에서 가져온다면 새로운 물건의 무게의 배수마다 이미 물건이 추가된 해에 중복해서 물건을 추가하여 계산하게 되어 잘못된 계산을 하게 됩니다.

# 구현 코드
```python
import sys
input = sys.stdin.readline

N,K = map(int, input().rstrip().split())
T = [ list(map(int, input().rstrip().split())) for _ in range(N) ]

dp = [ [0 for _ in range(K+1)] for _ in range(N)]

for i in range(1,K+1):
    if i >= T[0][0]:
        dp[0][i] = T[0][1]
        
for i in range(1,N):
    w,v = T[i]
    # 이전 부분해 가져오기 
    for j in range(1,K+1):
        # 새로 추가된 물건을 선택할 수 없을 때는 이전과 같음
        if j < w:
            dp[i][j] = dp[i-1][j]
        # 새로 추가한 물건을 선택하고 나머지 무게를 이전 최댓값으로 채운 것이 더 크다면 최대값 갱신
        else:
            dp[i][j] = max(dp[i-1][j], v+dp[i-1][j-w])
print(dp[N-1][K])
```

#### 인사이트
- DP문제는 시뮬레이션을 돌려보며 부분 문제 구조를 찾자 
- 부분 문제의 해를 가져올 때, 명확하게 어떤 경우의 해를 가져올 지 잘 생각하자 
---

### 동전
[Coins](https://www.acmicpc.net/problem/3067)
동전 문제도 유명한 DP 문제 중 하나입니다.

이 동전
### LCS

### LCS2

### 내리막길

### 사회망 서비스